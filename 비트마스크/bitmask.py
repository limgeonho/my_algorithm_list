# 비트마스크
# 비트마스크는 알고리즘이 아닌 문제풀이 기법중 한가지 방법이다.
# 비트마스크의 장점은 집합의 원소들을 전부 나열하는 것이 아닌 숫자하나로 표현한다는 점이다.
# ex) A = {1, 2, 3} => A[14]로 나타낼 수 있음 (14 = 2 + 4 + 8)
# 비트마스크는 주로 1) 브루트포스, 2) DP에서 활용한다.
# 연산속도가 빠르다.
# 모든 경우의 수(O, X 하는 문제)를 2진수로 나타내고 1의 위치에 따라(O, X)여부를 파악
# 2진수를 10진수로 바꿔서 완료(10진수를 2진수로 바꾸고 1의 위치에 따라 해당 원소가 있는지 없는지 파악)


# ===================================================================
# 부분집합관련 연산

# S에 i를 추가 : S |= (1 << i)

# S에서 i를 제거 : S &= ~(1 << i)

# S에 i가 있는지 검사 : S & (1 << i)

# 전체 집합은 (1<<N) - 1 로, 공집합은 0으로 나타낼 수 있다.

# 1 << N - 1 은 1 << (N - 1) 이라고 봐야한다.

# ===================================================================
# shift 연산
# 1<<0 == 1
# 1<<1 == 10
# 1<<2 == 100
# 1<<3 == 1000

# ===================================================================
# 부분집합 구하기
# 1<<n => 부분집합의 개수(n개의 원소일 때) = 1 * (2**n)

arr = [1, 2, 3]
n = len(arr)

# range(1 << n) => 공집합 포함, range(1, 1 << n) => 공집합 미포함
for i in range(1 << n):   # i : 0 ~ 7까지 숫자
    for j in range(n):    # n : 0 ~ 2까지 숫자
        if i & (1 << j):  # i와 (1<<j)의 비트 &연산(&연산 == i를 2진수로 바꿨을 때 j가 포함되어 있는지)
            print((i, j), arr[j], end=' ')  # 있으면 부분집합임
    print()

# (1, 0) 1                    => 1
# (2, 1) 2                    => 2
# (3, 0) 1 (3, 1) 2           => 1 2
# (4, 2) 3                    => 3
# (5, 0) 1 (5, 2) 3           => 1 3
# (6, 1) 2 (6, 2) 3           => 2 3
# (7, 0) 1 (7, 1) 2 (7, 2) 3  => 1 2 3
# ===================================================================
