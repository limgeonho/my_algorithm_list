## 알고리즘 기억할 것...

==================================================================

반올림해서 소수점 셋째 자리까지 출력
print(f'{answer:.3f}%')

==================================================================

set()끼리 빼버리는 차집합도 생각하자

==================================================================

수의 자리수를 다루는 문제는 str(x)로 변환하거나 자리수에 10을 나누고 나머지를 구하는 방법 활용

==================================================================

readline랑 read 차이 구별하기

==================================================================

문자열이나 리스트가 주어지면 index도 활용해보기

==================================================================

for char in c_alpha:
    s = s.replace(char, '0')
=> replace한 문자열s를 다시 s에 넣고 또다시 바뀐 s로 다시 돌림

==================================================================

계차수열
while True:
        a = a + plus
        plus += 6

==================================================================

n = [1,2,3]
random.shuffle(n) => 하면 리스트가 랜덤으로 섞여서 반환

==================================================================

lambda를 이용한 sort()

money = { "백원" : 100, "1$" : 1200, "10$" : 12000, "오천원" : 5000, "만원" : 10000, "100$" : 120000, "오만원" : 50000 }
=> money의 value를 기준으로 오름차순 정렬

money = sorted(money.items(), key = lambda x : x[1]) 
=> money.items()를 추가해서 key와 value의 튜플로 x를 받아내는 것이 핵심

출력 값 
[('백원', 100), ('1$', 1200), ('오천원', 5000), ('만원', 10000), ('10$', 12000), ('오만원', 50000), ('100$', 120000)]

sorting하는 기준을 여러개 넣을 수 도 있다.

data = ["나라","가구","봄","가을","도토리","낫","혹","가을 아침","나는 밥을 먹고 있다."]
=> 문자열의 길이 -> 사전 순으로 정렬

data.sort(key = lambda x:(len(x),x))
=> lambda x:(len(x),x)에서 (len(x),x)처럼 2가지 요소를 선언함으로 두개의 기준을 적용할 수 있다.

==================================================================

유클리드 거리 - 일반적으로 수학에서 말하는 거리 구하는 공식

맨해튼 거리 - 좌표의 차이 => |a2 - a1| + |b2 - b1|

==================================================================

defaultdict()에 대해... 

from collections import defaultdict
=> 해당하는 key값이 없을 경우에 바로 default 값을 0으로 지정해서 넣어준다

list_dict = defaultdict(list)
set_dict = defaultdict(set)
=> default 값을 list와 set으로 미리 설정할 수 도 있음

=> Counter과 같은 역할임 

==================================================================

itertools.chain에 대해...
=> 배열을 하나의 배열로 합쳐버림

letters = ['A', 'B', 'C', 'D']
booleans = [0, 1, 0, 1, 0, 1]

print(list(itertools.chain(letters, booleans)))
=> ['A', 'B', 'C', 'D', 0, 1, 0, 1, 0, 1]

==================================================================

eval()에 대해...

eval함수 안에는 문자열이 들어온다

=> 문자열이 들어와도 식을 계산한다

eval("1 + 2")

=> 3

==================================================================

전치행렬에 대해...=> 가로세로 따로 탐색할 때 유용함

=> 가로에 관해 함수를 만들고 => 전치행렬을 통해 뒤집고 => 다시 가로에 관한 함수 재사용

=> T = list(zip(*matrix))

==================================================================

orderedDict

from collections import orderedDict 로 사용

dict는 원래 순서가 없지만 orderdict는 순서가 있음

```python
order_dict = orderedDict()

order_dict['A'] = 1
order_dict['B'] = 2
order_dict['C'] = 3

OrderedDict([('A', 1), ('B', 2), ('C', 3)])
for key, val in ordered_dic.items():
	print(key, val)

A 1
B 2
C 3
# => dict에 입력되는 순서대로 저장됨 
```

popitem(last=True)

=> orderedDict에서 마지막에 있는 아이템들을 return 및 삭제함

popitem(last=False)

=> orderedDict에서 처음에 있는 아이템들을 return 및 삭제함

==================================================================

 문자열 앞에 0으로 채우기 => zfill()

- str.zfill(5) => str문자 앞에 전체 길이 5가 되도록 0으로 채우기

```python
"3".zfill(3)
# 003

"s".zfill(5)
# 0000s

for x in range(3):
    print(str(x).zfill(4))
# 0000
# 0001
# 0002
```

- rjust(), ljust() 

=> rjust(`<만들 전체 개수>`, `<채워 넣을 문자>`) : str을 오른쪽정렬

=> ljust(`<만들 전체 개수>`, `<채워 넣을 문자>`) : str을 왼쪽정렬

```python
"77".rjust(5, "0")
# 00077

"123".rjust(5, "a")
# aa123

"222".ljust(5, "0")
# 22200

"222"ljust(7, "aa")
# 222aaaaa
```

==================================================================

숫자의 각 자리수 더하는 방법

