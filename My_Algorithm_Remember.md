## 알고리즘 기억할 것...

==================================================================

반올림해서 소수점 셋째 자리까지 출력
print(f'{answer:.3f}%')

==================================================================

set()끼리 빼버리는 차집합도 생각하자

==================================================================

수의 자리수를 다루는 문제는 str(x)로 변환하거나 자리수에 10을 나누고 나머지를 구하는 방법 활용

==================================================================

readline랑 read 차이 구별하기

==================================================================

문자열이나 리스트가 주어지면 index도 활용해보기

==================================================================

for char in c_alpha:
    s = s.replace(char, '0')
=> replace한 문자열s를 다시 s에 넣고 또다시 바뀐 s로 다시 돌림

==================================================================

계차수열
while True:
        a = a + plus
        plus += 6

==================================================================

n = [1,2,3]
random.shuffle(n) => 하면 리스트가 랜덤으로 섞여서 반환

==================================================================

lambda를 이용한 sort()

money = { "백원" : 100, "1$" : 1200, "10$" : 12000, "오천원" : 5000, "만원" : 10000, "100$" : 120000, "오만원" : 50000 }
=> money의 value를 기준으로 오름차순 정렬

money = sorted(money.items(), key = lambda x : x[1]) 
=> money.items()를 추가해서 key와 value의 튜플로 x를 받아내는 것이 핵심

출력 값 
[('백원', 100), ('1$', 1200), ('오천원', 5000), ('만원', 10000), ('10$', 12000), ('오만원', 50000), ('100$', 120000)]

sorting하는 기준을 여러개 넣을 수 도 있다.

data = ["나라","가구","봄","가을","도토리","낫","혹","가을 아침","나는 밥을 먹고 있다."]
=> 문자열의 길이 -> 사전 순으로 정렬

data.sort(key = lambda x:(len(x),x))
=> lambda x:(len(x),x)에서 (len(x),x)처럼 2가지 요소를 선언함으로 두개의 기준을 적용할 수 있다.

==================================================================

유클리드 거리 - 일반적으로 수학에서 말하는 거리 구하는 공식

맨해튼 거리 - 좌표의 차이 => |a2 - a1| + |b2 - b1|

==================================================================

defaultdict()에 대해... 

from collections import defaultdict
=> 해당하는 key값이 없을 경우에 바로 default 값을 0으로 지정해서 넣어준다

list_dict = defaultdict(list)
set_dict = defaultdict(set)
=>default 값을 list와 set으로 미리 설정할 수 도 있음

=> Counter과 같은 역할임 

==================================================================

itertools.chain에 대해...
=> 배열을 하나의 배열로 합쳐버림

letters = ['A', 'B', 'C', 'D']
booleans = [0, 1, 0, 1, 0, 1]

print(list(itertools.chain(letters, booleans)))
=> ['A', 'B', 'C', 'D', 0, 1, 0, 1, 0, 1]

==================================================================

eval()에 대해...

eval함수 안에는 문자열이 들어온다

=> 문자열이 들어와도 식을 계산한다

eval("1 + 2")

=> 3

==================================================================

전치행렬에 대해...=> 가로세로 따로 탐색할 때 유용함

=> 가로에 관해 함수를 만들고 => 전치행렬을 통해 뒤집고 => 다시 가로에 관한 함수 재사용

```python
def transposed_matrix(array):
	row = len(array)
	col = len(array[0])
	changed_array = [[0]*(row) for _ in range(col)]
        
	for i in range(row):
		for j in range(col):
			changed_array[j][i] = array[i][j]
	return changed_array
             
# ================================================================================
def transposed_matrix(array):
    changed_array = [[0]*(n) for _ in range(n)]
    for i in range(n):
        for j in range(n):
            changed_array[i][j] = array[j][i]
    return changed_array
```

